<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>µPCI</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>µPCI</h1>
        <h2>O microprocessador.</h2>
        <a href="https://github.com/upci/upci" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="%C2%B5pci" class="anchor" href="#%C2%B5pci"><span class="octicon octicon-link"></span></a>µPCI</h1>

<blockquote>
<p>Inspiração: Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology) </p>
</blockquote>

<p>Projeto final da disciplina Prototipação de Circuitos Integrados - POLI/UPE, 2014-1. Desenvolvido utilizando o Quartus II 13.0 sp1.</p>

<h2>
<a name="introdu%C3%A7%C3%A3o" class="anchor" href="#introdu%C3%A7%C3%A3o"><span class="octicon octicon-link"></span></a>Introdução</h2>

<p>O objetivo principal deste projeto é a construção de um µProcessador, que foi feita tendo como base a descrição de um processador no documento "Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology)". Como o comportamento do processador desenvolvido é semelhante ao de um processador comum (como o que encontramos em nossos computadores, smartphones, etc), também será possível escrever programas (dado o conjunto de instruções existentes no processador) para serem executados pelo FPGA, claro, após passá-los por um tradutor que os converterá de um código MIPS para linguagem de máquina em binário.</p>

<h2>
<a name="implementa%C3%A7%C3%A3o" class="anchor" href="#implementa%C3%A7%C3%A3o"><span class="octicon octicon-link"></span></a>Implementação</h2>

<h3>
<a name="modelo-estrutural" class="anchor" href="#modelo-estrutural"><span class="octicon octicon-link"></span></a>Modelo Estrutural</h3>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/ModeloEstrutural.png" alt="Structural Model of the Microprocessor" title="Structural Model of the Microprocessor"></p>

<p>O modelo estrutural do processador implementado neste projeto segue o que está mostrado na imagem acima. Possui uma Unidade de Controle, um contador de programa, um acumulador, um registrador de dados, um de endereços e um de instruções, uma memória interna e um barramento que passam dados e endereços de memória.</p>

<p>As seções abaixo descrevem, com mais detalhes, como foram implementados cada componente. Nota-se que, além destas, há ainda uma entidade top-level chamada "processor", onde há a instanciação destas como componentes e a conexão dos respectivos sinais.</p>

<h3>
<a name="conjunto-de-instru%C3%A7%C3%B5es" class="anchor" href="#conjunto-de-instru%C3%A7%C3%B5es"><span class="octicon octicon-link"></span></a>Conjunto de Instruções</h3>

<table>
<thead><tr>
<th>Comando</th>
<th>Opcode (Binário)</th>
</tr></thead>
<tbody>
<tr>
<td>LOAD endereço</td>
<td>0000</td>
</tr>
<tr>
<td>STORE endereço</td>
<td>0001</td>
</tr>
<tr>
<td>ADD endereço</td>
<td>0010</td>
</tr>
<tr>
<td>SUB endereço</td>
<td>0011</td>
</tr>
<tr>
<td>INC</td>
<td>0100</td>
</tr>
<tr>
<td>DEC</td>
<td>0101</td>
</tr>
<tr>
<td>NOTT endereco</td>
<td>0110</td>
</tr>
<tr>
<td>ANDD endereço</td>
<td>0111</td>
</tr>
<tr>
<td>ORR endereço</td>
<td>1000</td>
</tr>
<tr>
<td>XORR endereço</td>
<td>1001</td>
</tr>
<tr>
<td>J endereço</td>
<td>1010</td>
</tr>
<tr>
<td>BE endereço</td>
<td>1011</td>
</tr>
<tr>
<td>BG endereço</td>
<td>1100</td>
</tr>
<tr>
<td>BL endereço</td>
<td>1101</td>
</tr>
<tr>
<td>WAITT</td>
<td>1110</td>
</tr>
<tr>
<td>NOP</td>
<td>1111</td>
</tr>
</tbody>
</table><h3>
<a name="program-counter-pc" class="anchor" href="#program-counter-pc"><span class="octicon octicon-link"></span></a>Program Counter (PC)</h3>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/PC.png" alt="PC" title="PC"></p>

<p>O módulo do PC deve conter 6 portas de entrada/saída. São elas:  </p>

<ul>
<li>Clock;</li>
<li>Reset ativo em 0;</li>
<li>Barramento de entrada e saída (PC_bus, barramento INOUT);</li>
<li>Sinal de incremento (PC_inc);</li>
<li>Carregar (PC_load);</li>
<li>Permissão de escrita no barramento (PC_valid, manda o valor do PC pro PC_bus quando ativo, ou Z quando inativo).</li>
</ul><p>Todos devem ser do tipo STD LOGIC, com exceção do PC_bus, que é STD LOGIC VECTOR.</p>

<p>Parte assíncrona: se a flag de valid for para 0, a saída no BUS deve ser colocada em Z imediatamente. Se reset for para 0, o valor do PC deve ir para 0.</p>

<p>Parte síncrona: na borda de subida, verifica-se as flags inc e load, em ordem de precedência. Isto é, se inc estiver em nível alto, não importa se load também está, deve ser realizado o incremento. Se inc estiver em nível baixo, verifica-se se load está em nível alto. Se estiver, carrega-se o valor do bus no PC. </p>

<h3>
<a name="instruction-register" class="anchor" href="#instruction-register"><span class="octicon octicon-link"></span></a>Instruction Register</h3>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/IR.png" alt="IR" title="IR"></p>

<p>O módulo do IR deve conter 6 portas de entrada/saída. São elas:  </p>

<ul>
<li>Clock;</li>
<li>Reset ativo em 0;</li>
<li>Barramento de entrada e saída (IR_bus, barramento INOUT);</li>
<li>Carregar (IR_load, flag para dizer se o IR está no modo load, carregando a instrução a ser executada pelo processador ou decodificada);</li>
<li>Permissão de escrita no barramento (IR_valid, flag que indica se o IR deve escrever seu conteúdo no barramento);</li>
<li>Opcode (IR_opcode, saída com o opcode decodificado);</li>
</ul><p>A função do IR é armazenar e decodificar o <em>opcode</em> em forma binária e então passá-lo para o bloco de controle.</p>

<p>Parte assíncrona: se a flag de valid for para 0, a saída no BUS deve ser colocada em Z imediatamente. Se reset for para 0, o valor do registrador interno deve ir para 0s.</p>

<p>Parte síncrona: na borda de subida, o valor do barramento deve ser enviado para o registrador interno e o opcode de saída deve ser decodificado assincronamente quando o valor no IR mudar.</p>

<h3>
<a name="arithmetic-logic-unit-alu" class="anchor" href="#arithmetic-logic-unit-alu"><span class="octicon octicon-link"></span></a>Arithmetic Logic Unit (ALU)</h3>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/ALU.png" alt="ALU" title="ALU"></p>

<p>O módulo de ALU (que compreende, na verdade, a ALU propriamente dita e o registrador ACC) contém 7 portas de entrada/saída. São elas:  </p>

<ul>
<li>Clock;</li>
<li>Reset ativo em 0;</li>
<li>Barramento de entrada e saída (ALU_bus, barramento INOUT, mesma idéia do PC_bus);</li>
<li>Comando (função) a ser realizado (ALU_cmd, com 4 bits, sinais de controle que indicam a função a ser realizada pela ALU);</li>
<li>Sinal de escrita no barramento (ALU_valid, manda o valor da ALU pro ALU_bus quando ativo, ou Z quando inativo);<br>
</li>
<li>ACC é zero (ALU_zero, fica em nível alto quando o valor armazenado no ACC é igual a zero).</li>
<li>ACC é menor que zero (ALU_slt), fica em nível alto quando o valor armazenado no ACC é menor que zero).</li>
</ul><p>Como dito, a ALU possui, internamente, um acumulador ACC do tamanho do barramento do sistema. É ele quem guarda o valor a ser enviado para o barramento quando o sinal ALU_valid está ativo, e é quando este é inteiramente zero que o ALU_zero é ativo. Ao ativar o sinal de reset (colocando-o em 0), reseta-se o valor do registrador interno (ACC) para 0.</p>

<p>Na borda de subida do clock, decodifica-se o valor do comando e realiza-se a operação em cima do ACC.</p>

<p>Os comandos possíveis são:</p>

<table>
<thead><tr>
<th>Comando</th>
<th>Operação</th>
</tr></thead>
<tbody>
<tr>
<td>0000</td>
<td>LOAD - Carrega o valor do barramento no ACC (ACC = 0 + BUS)</td>
</tr>
<tr>
<td>0001</td>
<td>ADD - Soma o valor do barramento ao ACC (ACC = ACC + BUS)</td>
</tr>
<tr>
<td>0010</td>
<td>NOT - Carrega no ACC a negação do valor do barramento (ACC = not BUS)</td>
</tr>
<tr>
<td>0011</td>
<td>OR - 'Ou' do valor do barramento com o ACC (ACC = ACC or BUS)</td>
</tr>
<tr>
<td>0100</td>
<td>AND - 'E' do valor do barramento com o ACC (ACC = ACC and BUS)</td>
</tr>
<tr>
<td>0101</td>
<td>XOR - 'Ou exclusivo' valor do barramento com o ACC (ACC = ACC xor BUS)</td>
</tr>
<tr>
<td>0110</td>
<td>INC - Incrementa o ACC (ACC = ACC + 1)</td>
</tr>
<tr>
<td>0111</td>
<td>SUB - Subtrai o valor do barramento do ACC (ACC = ACC - BUS)</td>
</tr>
<tr>
<td>1000</td>
<td>DEC - Decrementa o ACC (ACC = ACC - 1)</td>
</tr>
</tbody>
</table><h3>
<a name="mem%C3%B3ria-de-instru%C3%A7%C3%B5esdados" class="anchor" href="#mem%C3%B3ria-de-instru%C3%A7%C3%B5esdados"><span class="octicon octicon-link"></span></a>Memória de Instruções/Dados</h3>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/Memory.png" alt="Memory" title="Memory"></p>

<p>O módulo de memória deve conter 8 'pinos':  </p>

<ul>
<li>Clock;<br>
</li>
<li>Reset ativo em 0;<br>
</li>
<li>Ativação de carregamento do registrador MDR (MDR_load, MDR = Memory Data Register);<br>
</li>
<li>Ativação de carregamento do registrador MAR (MAR_load, MAR = Memory Address Register);<br>
</li>
<li>Permissão de escrita no barramento (MEM_valid, manda o valor lido na memória (registrador MDR) para o MEM_bus quando ativo, ou Z quando inativo);<br>
</li>
<li>Barramento de entrada e saída (MEM_bus, barramento INOUT, mesma idéia do PC_bus);<br>
</li>
<li>Flag de ativação da memória (MEM_en);<br>
</li>
<li>Flag de indicação de escrita ou leituar (MEM_rw, onde '0' indica leitura e '1' escrita);</li>
</ul><p>O módulo de memória é implementado em 3 partes:</p>

<ul>
<li>Carregamento do endereço a ser acessado (vem do BUS e é salvo no MAR);<br>
</li>
<li>Leitura ou escrita do dado presente no endereço indicado pelo MAR, utilizando o MDR;<br>
</li>
<li>Carregamento dos dados padrões na memória, toda vez que a mesma é resetada.</li>
</ul><h3>
<a name="controladora-de-io" class="anchor" href="#controladora-de-io"><span class="octicon octicon-link"></span></a>Controladora de IO</h3>

<p>A implementação do IO é feita com inspiração em Memory Mapped I/O, onde pode-se ler mais sobre na página da Wikipedia: <a href="http://en.wikipedia.org/wiki/Memory-mapped_I/O">http://en.wikipedia.org/wiki/Memory-mapped_I/O</a>. </p>

<p>Desta forma, decidiu-se que ao realizar acesso a memória, o seguinte mapeamento seria feito:</p>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/MMIO.png" alt="MMIO" title="MMIO"></p>

<p>Assim, tanto o módulo de memória quanto a controladora de IO deverão ouvir constantemente pelas requisições, mas só deverão responder caso o endereço a ser operado esteja dentro dos seus limites.</p>

<p>As entradas e saídas da controladora de IO são semelhantes a do módulo de Memória, isto é, possuem a mesma interface. A entidade pode ser visualizada na figura a seguir.</p>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/IO.png" alt="IO" title="IO"></p>

<p>Estão omitidas dessa imagem, entretanto, as conexões com os dispositivos de entrada e saída propriamente ditos, dado que isto depende de quais serão implementados.</p>

<p>Para a apresentação deste projeto, optou-se pela criação de 3 dispositivos: duas saídas para displays de 7 segmentos e uma entrada a partir de um conjunto de switches. Assim, associou-se a cada dispositivo um endereço (129, 130 e 128, respectivamente), e fez-se o devido tratamento para que as operações de LOAD e STORE realizassem o acesso correto aos mesmos.</p>

<h3>
<a name="unidade-de-controle-uc" class="anchor" href="#unidade-de-controle-uc"><span class="octicon octicon-link"></span></a>Unidade de Controle (UC)</h3>

<p>A função da Unidade de Controle é acessar o PC, pegar a instrução da memória, mover os dados quando necessário, configurando todos os sinais de controle no momento certo e com os valores corretos.
Dessa forma, a Unidade de Controle deve ter um clock e reset, conexão com o barramento global e saídas com todos sinais de controle:</p>

<ul>
<li>Clock;</li>
<li>Reset ativo em 0;</li>
<li>Opcode;</li>
<li>IR_load;</li>
<li>IR_valid;</li>
<li>IR_address;</li>
<li>PC_inc;</li>
<li>PC_load;</li>
<li>PC_valid;</li>
<li>MDR_load;</li>
<li>MDR_valid;</li>
<li>MAR_load;</li>
<li>MAR_valid;</li>
<li>MEM_en;</li>
<li>MEM_rw;</li>
<li>ALU_valid;</li>
<li>ALU_load;</li>
<li>ALU_cmd;</li>
<li>CONTROL_bus;</li>
<li>IODR_load</li>
<li>IOAR_load</li>
<li>IO_valid</li>
<li>IO_en</li>
<li>IO_rw</li>
<li>WAKE_signal (novo sinal, de entrada, que serve para sair do estado de WAIT)</li>
</ul><p>A Unidade de controle pode ser implementada por uma máquina de estado que controla o fluxo de sinais no processador. O diagrama da máquina de estado pode ser conferido na imagem abaixo.</p>

<p><img src="/upci/Documenta%C3%A7%C3%A3o/UnidadeDeControle.png" alt="Basic Processor Controller State Machine" title="Basic Processor Controller State Machine"></p>

<table>
<thead><tr>
<th>Estado</th>
<th>Descrição</th>
<th>Sinais Ativos</th>
</tr></thead>
<tbody>
<tr>
<td>s0</td>
<td>Busca de instrução: manda o valor do PC para o barramento e incrementa o PC. Além disso, carrega o endereço do barramento (valor do PC) no MAR, seguindo para s1.</td>
<td>MAR_load, PC_valid, PC_inc</td>
</tr>
<tr>
<td>s1</td>
<td>Busca de instrução: ativa memória para R/W e configura para leitura (valor no endereço de memória que está em MAR é armazenado em MDR, isto é, carregamos a próxima linha de código a ser executada), seguindo para s2.</td>
<td>MEM_en</td>
</tr>
<tr>
<td>s2</td>
<td>Busca de instrução/Decodificação: Carregamento do que foi lido na memória para o IR, seguindo para s3.</td>
<td>MEM_valid, IR_load</td>
</tr>
<tr>
<td>s3</td>
<td>Envio do valor armazenado em IR para o barramento, carregando no MAR. Se a instrução for NOP, retorna ao estado inicial s0.</td>
<td>IR_valid, MAR_load, IOAR_load</td>
</tr>
<tr>
<td>s4</td>
<td>Se a instrução for de STORE, armazena o valor do acumulador no MDR e segue para o s5.</td>
<td>ALU_valid, MDR_load, IODR_load</td>
</tr>
<tr>
<td>s5</td>
<td>Escreve o valor armazenado no MDR na posição de memória armazenada no MAR. Após isso, retorna ao estado inicial s0.</td>
<td>MEM_en, MEM_rw, IO_en, IO_rw</td>
</tr>
<tr>
<td>s6</td>
<td>Carrega para MDR o valor da posição de memória armazenado no MAR e segue para o estado s7.</td>
<td>MEM_en, IO_en</td>
</tr>
<tr>
<td>s7</td>
<td>Habilita a memória para escrita no barramento e resgata o valor que está no MDR. Ativa, também, a ALU com a operação a ser realizada. Após isso, retorna ao estado inicial s0.</td>
<td>MEM_valid, IO_valid, ALU_enable, ALU_cmd</td>
</tr>
<tr>
<td>s8</td>
<td>Se, no estado S3, a instrução for BLESS, BGREATER ou BZERO, e o BRANCH_Trigger estiver ativo, se segue para o estado s9, caso contrário, retorna-se ao s0.</td>
<td>-</td>
</tr>
<tr>
<td>s9</td>
<td>Realiza o JUMP, carregando no PC a instrução da posição de memória indicada pelo IR. Após isso, retorna ao estado inicial s0.</td>
<td>IR_valid, PC_load</td>
</tr>
<tr>
<td>s10</td>
<td>Se, no estado S3, a instrução for WAIT, o processador espera até que seja recebido um sinal de WAKE para que ele retorne ao estado 0, continuando o fluxo de buscas de instruções. Após isso, retorna ao estado inicial s0.</td>
<td>WAITING</td>
</tr>
</tbody>
</table><p>Percebe-se a utilização da função cmdDecode, onde é realizada a conversão do opcode da instrução a ser realizada para o comando a ser executado pela ALU.</p>

<h3>
<a name="dificuldades" class="anchor" href="#dificuldades"><span class="octicon octicon-link"></span></a>Dificuldades</h3>

<ul>
<li>A utilização de memória com sinal de reset não pôde ser inferida para memória RAM pelo sintetizador do Quartus II. Assim, tivemos que reduzir a quantidade de bits para que fosse possível gerar uma memória com uma quantidade menor e mais viável de componentes.</li>
<li>Visualização de sinais internos -- que não são portas da top-level entity -- é complicada: não é possível fazer mapeamento diretamente para leds e switches. A solução mais provável seria a utilização de SignalProbes, mas que só está disponível na versão paga do Quartus II.</li>
<li>Descrição do IO como Memory Mapped foi, a princípio, complicada.</li>
</ul>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/upci/upci/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/upci/upci/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/upci/upci"></a> is maintained by <a href="https://github.com/upci">upci</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>