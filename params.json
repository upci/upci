{"name":"Upci","tagline":"O microprocessador.","body":"µPCI\r\n======================\r\n\r\n> Inspiração: Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology) \r\n\r\nProjeto final da disciplina Prototipação de Circuitos Integrados - POLI/UPE, 2014-1. Desenvolvido utilizando o Quartus II 13.0 sp1.\r\n\r\n## Introdução\r\n\r\nO objetivo principal deste projeto é a construção de um µProcessador, que foi feita tendo como base a descrição de um processador no documento \"Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology)\". Como o comportamento do processador desenvolvido é semelhante ao de um processador comum (como o que encontramos em nossos computadores, smartphones, etc), também será possível escrever programas (dado o conjunto de instruções existentes no processador) para serem executados pelo FPGA, claro, após passá-los por um tradutor que os converterá de um código MIPS para linguagem de máquina em binário.\r\n\r\n## Implementação\r\n### Modelo Estrutural\r\n\r\n![Structural Model of the Microprocessor](/Documentação/ModeloEstrutural.png \"Structural Model of the Microprocessor\")\r\n\r\nO modelo estrutural do processador implementado neste projeto segue o que está mostrado na imagem acima. Possui uma Unidade de Controle, um contador de programa, um acumulador, um registrador de dados, um de endereços e um de instruções, uma memória interna e um barramento que passam dados e endereços de memória.\r\n\r\nAs seções abaixo descrevem, com mais detalhes, como foram implementados cada componente. Nota-se que, além destas, há ainda uma entidade top-level chamada \"processor\", onde há a instanciação destas como componentes e a conexão dos respectivos sinais.\r\n\r\n### Conjunto de Instruções\r\n\r\n| Comando\t\t\t| Opcode (Binário)\t|\r\n|-------------------|-------------------|\r\n| LOAD endereço\t\t| 0000\t\t\t\t|\r\n| STORE endereço\t| 0001\t\t\t\t|\r\n| ADD endereço\t\t| 0010\t\t\t\t|\r\n| SUB endereço\t\t| 0011\t\t\t\t|\r\n| INC\t\t\t\t| 0100\t\t\t\t|\r\n| DEC\t\t\t\t| 0101\t\t\t\t|\r\n| NOTT endereco\t\t| 0110\t\t\t\t|\r\n| ANDD endereço\t\t| 0111\t\t\t\t|\r\n| ORR endereço\t\t| 1000\t\t\t\t|\r\n| XORR endereço\t\t| 1001\t\t\t\t|\r\n| J endereço\t\t| 1010\t\t\t\t|\r\n| BE endereço\t\t| 1011\t\t\t\t|\r\n| BG endereço\t\t| 1100\t\t\t\t|\r\n| BL endereço\t\t| 1101\t\t\t\t|\r\n| WAITT\t\t\t\t| 1110\t\t\t\t|\r\n| NOP\t\t\t\t| 1111\t\t\t\t|\r\n\r\n### Program Counter (PC)\r\n\r\n![PC](/Documentação/PC.png \"PC\")\r\n\r\nO módulo do PC deve conter 6 portas de entrada/saída. São elas:  \r\n* Clock;\r\n* Reset ativo em 0;\r\n* Barramento de entrada e saída (PC_bus, barramento INOUT);\r\n* Sinal de incremento (PC_inc);\r\n* Carregar (PC_load);\r\n* Permissão de escrita no barramento (PC_valid, manda o valor do PC pro PC_bus quando ativo, ou Z quando inativo).\r\n\r\nTodos devem ser do tipo STD LOGIC, com exceção do PC_bus, que é STD LOGIC VECTOR.\r\n\r\nParte assíncrona: se a flag de valid for para 0, a saída no BUS deve ser colocada em Z imediatamente. Se reset for para 0, o valor do PC deve ir para 0.\r\n\r\nParte síncrona: na borda de subida, verifica-se as flags inc e load, em ordem de precedência. Isto é, se inc estiver em nível alto, não importa se load também está, deve ser realizado o incremento. Se inc estiver em nível baixo, verifica-se se load está em nível alto. Se estiver, carrega-se o valor do bus no PC. \r\n\r\n\r\n### Instruction Register\r\n\r\n![IR](/Documentação/IR.png \"IR\")\r\n\r\nO módulo do IR deve conter 6 portas de entrada/saída. São elas:  \r\n* Clock;\r\n* Reset ativo em 0;\r\n* Barramento de entrada e saída (IR_bus, barramento INOUT);\r\n* Carregar (IR_load, flag para dizer se o IR está no modo load, carregando a instrução a ser executada pelo processador ou decodificada);\r\n* Permissão de escrita no barramento (IR_valid, flag que indica se o IR deve escrever seu conteúdo no barramento);\r\n* Opcode (IR_opcode, saída com o opcode decodificado);\r\n\r\nA função do IR é armazenar e decodificar o *opcode* em forma binária e então passá-lo para o bloco de controle.\r\n\r\nParte assíncrona: se a flag de valid for para 0, a saída no BUS deve ser colocada em Z imediatamente. Se reset for para 0, o valor do registrador interno deve ir para 0s.\r\n\r\nParte síncrona: na borda de subida, o valor do barramento deve ser enviado para o registrador interno e o opcode de saída deve ser decodificado assincronamente quando o valor no IR mudar.\r\n\r\n### Arithmetic Logic Unit (ALU)\r\n\r\n![ALU](/Documentação/ALU.png \"ALU\")\r\n\r\nO módulo de ALU (que compreende, na verdade, a ALU propriamente dita e o registrador ACC) contém 7 portas de entrada/saída. São elas:  \r\n\r\n* Clock;\r\n* Reset ativo em 0;\r\n* Barramento de entrada e saída (ALU_bus, barramento INOUT, mesma idéia do PC_bus);\r\n* Comando (função) a ser realizado (ALU_cmd, com 4 bits, sinais de controle que indicam a função a ser realizada pela ALU);\r\n* Sinal de escrita no barramento (ALU_valid, manda o valor da ALU pro ALU_bus quando ativo, ou Z quando inativo);  \r\n* ACC é zero (ALU_zero, fica em nível alto quando o valor armazenado no ACC é igual a zero).\r\n* ACC é menor que zero (ALU_slt), fica em nível alto quando o valor armazenado no ACC é menor que zero).\r\n\r\nComo dito, a ALU possui, internamente, um acumulador ACC do tamanho do barramento do sistema. É ele quem guarda o valor a ser enviado para o barramento quando o sinal ALU_valid está ativo, e é quando este é inteiramente zero que o ALU_zero é ativo. Ao ativar o sinal de reset (colocando-o em 0), reseta-se o valor do registrador interno (ACC) para 0.\r\n\r\nNa borda de subida do clock, decodifica-se o valor do comando e realiza-se a operação em cima do ACC.\r\n\r\nOs comandos possíveis são:\r\n\r\n| Comando\t| Operação \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\r\n|-----------|-----------------------------------------------------------------------|\r\n| 0000 \t\t| LOAD - Carrega o valor do barramento no ACC (ACC = 0 + BUS) \t\t\t|\r\n| 0001 \t\t| ADD - Soma o valor do barramento ao ACC (ACC = ACC + BUS) \t\t\t|\r\n| 0010 \t\t| NOT - Carrega no ACC a negação do valor do barramento (ACC = not BUS)\t|\r\n| 0011 \t\t| OR - 'Ou' do valor do barramento com o ACC (ACC = ACC or BUS) \t\t|\r\n| 0100 \t\t| AND - 'E' do valor do barramento com o ACC (ACC = ACC and BUS) \t\t|\r\n| 0101 \t\t| XOR - 'Ou exclusivo' valor do barramento com o ACC (ACC = ACC xor BUS)|\r\n| 0110 \t\t| INC - Incrementa o ACC (ACC = ACC + 1) \t\t\t\t\t\t\t\t|\r\n| 0111 \t\t| SUB - Subtrai o valor do barramento do ACC (ACC = ACC - BUS) \t\t\t|\r\n| 1000\t\t| DEC - Decrementa o ACC (ACC = ACC - 1)\t\t\t\t\t\t\t\t|\r\n\r\n### Memória de Instruções/Dados\r\n\r\n![Memory](/Documentação/Memory.png \"Memory\")\r\n\r\nO módulo de memória deve conter 8 'pinos':  \r\n* Clock;  \r\n* Reset ativo em 0;  \r\n* Ativação de carregamento do registrador MDR (MDR_load, MDR = Memory Data Register);  \r\n* Ativação de carregamento do registrador MAR (MAR_load, MAR = Memory Address Register);  \r\n* Permissão de escrita no barramento (MEM_valid, manda o valor lido na memória (registrador MDR) para o MEM_bus quando ativo, ou Z quando inativo);  \r\n* Barramento de entrada e saída (MEM_bus, barramento INOUT, mesma idéia do PC_bus);  \r\n* Flag de ativação da memória (MEM_en);  \r\n* Flag de indicação de escrita ou leituar (MEM_rw, onde '0' indica leitura e '1' escrita);\r\n  \r\nO módulo de memória é implementado em 3 partes:\r\n* Carregamento do endereço a ser acessado (vem do BUS e é salvo no MAR);  \r\n* Leitura ou escrita do dado presente no endereço indicado pelo MAR, utilizando o MDR;  \r\n* Carregamento dos dados padrões na memória, toda vez que a mesma é resetada.\r\n \r\n\r\n### Controladora de IO\r\n\r\nA implementação do IO é feita com inspiração em Memory Mapped I/O, onde pode-se ler mais sobre na página da Wikipedia: http://en.wikipedia.org/wiki/Memory-mapped_I/O. \r\n\r\nDesta forma, decidiu-se que ao realizar acesso a memória, o seguinte mapeamento seria feito:\r\n\r\n![MMIO](/Documentação/MMIO.png \"MMIO\")\r\n\r\nAssim, tanto o módulo de memória quanto a controladora de IO deverão ouvir constantemente pelas requisições, mas só deverão responder caso o endereço a ser operado esteja dentro dos seus limites.\r\n\r\nAs entradas e saídas da controladora de IO são semelhantes a do módulo de Memória, isto é, possuem a mesma interface. A entidade pode ser visualizada na figura a seguir.\r\n\r\n![IO](/Documentação/IO.png \"IO\")\r\n\r\nEstão omitidas dessa imagem, entretanto, as conexões com os dispositivos de entrada e saída propriamente ditos, dado que isto depende de quais serão implementados.\r\n\r\nPara a apresentação deste projeto, optou-se pela criação de 3 dispositivos: duas saídas para displays de 7 segmentos e uma entrada a partir de um conjunto de switches. Assim, associou-se a cada dispositivo um endereço (129, 130 e 128, respectivamente), e fez-se o devido tratamento para que as operações de LOAD e STORE realizassem o acesso correto aos mesmos.\r\n\r\n### Unidade de Controle (UC)\r\n\r\nA função da Unidade de Controle é acessar o PC, pegar a instrução da memória, mover os dados quando necessário, configurando todos os sinais de controle no momento certo e com os valores corretos.\r\nDessa forma, a Unidade de Controle deve ter um clock e reset, conexão com o barramento global e saídas com todos sinais de controle:\r\n\r\n* Clock;\r\n* Reset ativo em 0;\r\n* Opcode;\r\n* IR_load;\r\n* IR_valid;\r\n* IR_address;\r\n* PC_inc;\r\n* PC_load;\r\n* PC_valid;\r\n* MDR_load;\r\n* MDR_valid;\r\n* MAR_load;\r\n* MAR_valid;\r\n* MEM_en;\r\n* MEM_rw;\r\n* ALU_valid;\r\n* ALU_load;\r\n* ALU_cmd;\r\n* CONTROL_bus;\r\n* IODR_load\r\n* IOAR_load\r\n* IO_valid\r\n* IO_en\r\n* IO_rw\r\n* WAKE_signal (novo sinal, de entrada, que serve para sair do estado de WAIT)\r\n\r\nA Unidade de controle pode ser implementada por uma máquina de estado que controla o fluxo de sinais no processador. O diagrama da máquina de estado pode ser conferido na imagem abaixo.\r\n\r\n![Basic Processor Controller State Machine](/Documentação/UnidadeDeControle.png \"Basic Processor Controller State Machine\")\r\n\r\n| Estado\t| Descrição \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| Sinais Ativos \t\t\t\t\t\t\t|\r\n|-----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------|\r\n| s0 \t\t| Busca de instrução: manda o valor do PC para o barramento e incrementa o PC. Além disso, carrega o endereço do barramento (valor do PC) no MAR, seguindo para s1.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| MAR_load, PC_valid, PC_inc\t\t\t\t|\r\n| s1 \t\t| Busca de instrução: ativa memória para R/W e configura para leitura (valor no endereço de memória que está em MAR é armazenado em MDR, isto é, carregamos a próxima linha de código a ser executada), seguindo para s2.\t\t| MEM_en \t\t\t\t\t\t\t\t\t|\r\n| s2 \t\t| Busca de instrução/Decodificação: Carregamento do que foi lido na memória para o IR, seguindo para s3.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| MEM_valid, IR_load \t\t\t\t\t\t|\r\n| s3 \t\t| Envio do valor armazenado em IR para o barramento, carregando no MAR. Se a instrução for NOP, retorna ao estado inicial s0.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| IR_valid, MAR_load, IOAR_load\t\t\t\t|\r\n| s4 \t\t| Se a instrução for de STORE, armazena o valor do acumulador no MDR e segue para o s5.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| ALU_valid, MDR_load, IODR_load\t\t\t|\r\n| s5 \t\t| Escreve o valor armazenado no MDR na posição de memória armazenada no MAR. Após isso, retorna ao estado inicial s0. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| MEM_en, MEM_rw, IO_en, IO_rw\t\t\t\t|\r\n| s6 \t\t| Carrega para MDR o valor da posição de memória armazenado no MAR e segue para o estado s7. \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| MEM_en, IO_en \t\t\t\t\t\t\t|\r\n| s7\t\t| Habilita a memória para escrita no barramento e resgata o valor que está no MDR. Ativa, também, a ALU com a operação a ser realizada. Após isso, retorna ao estado inicial s0.\t\t\t\t\t\t\t\t\t\t\t\t| MEM_valid, IO_valid, ALU_enable, ALU_cmd\t|\r\n| s8\t\t| Se, no estado S3, a instrução for BLESS, BGREATER ou BZERO, e o BRANCH_Trigger estiver ativo, se segue para o estado s9, caso contrário, retorna-se ao s0.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| -\t\t\t\t\t\t\t\t\t\t\t|\r\n| s9\t\t| Realiza o JUMP, carregando no PC a instrução da posição de memória indicada pelo IR. Após isso, retorna ao estado inicial s0.\t\t\t\t\t\t\t\t\t\t| IR_valid, PC_load\t\t\t\t\t\t\t\t\t\t\t|\t\t\t\t\t\t\t\t\t\t\t|\r\n| s10\t\t| Se, no estado S3, a instrução for WAIT, o processador espera até que seja recebido um sinal de WAKE para que ele retorne ao estado 0, continuando o fluxo de buscas de instruções. Após isso, retorna ao estado inicial s0.\t| WAITING\t\t\t\t\t\t\t\t\t|\r\n\r\nPercebe-se a utilização da função cmdDecode, onde é realizada a conversão do opcode da instrução a ser realizada para o comando a ser executado pela ALU.\r\n\r\n### Dificuldades\r\n\r\n* A utilização de memória com sinal de reset não pôde ser inferida para memória RAM pelo sintetizador do Quartus II. Assim, tivemos que reduzir a quantidade de bits para que fosse possível gerar uma memória com uma quantidade menor e mais viável de componentes.\r\n* Visualização de sinais internos -- que não são portas da top-level entity -- é complicada: não é possível fazer mapeamento diretamente para leds e switches. A solução mais provável seria a utilização de SignalProbes, mas que só está disponível na versão paga do Quartus II.\r\n* Descrição do IO como Memory Mapped foi, a princípio, complicada.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}